{"ast":null,"code":"export default class Bomb {\n  static renderBomb(ctx, position) {\n    ctx.fillStyle = \"#ff0000\";\n    ctx.fillRect(position[0], position[1], 48, 48);\n  }\n\n  static renderExplosion(ctx, position) {\n    ctx.fillStyle = \"#ffff00\";\n    ctx.fillRect(position[0], position[1], 48, 48);\n  }\n\n  constructor(player) {\n    // this.img = '';\n    // this.flickerIntervalId = null;\n    // this.ctx = ctx;\n    // this.grid = grid;\n    this.player = player;\n    this.deploy = this.deploy.bind(this);\n    this.explodeBothWays = this.explodeBothWays.bind(this); // this.explode = this.explode.bind(this);\n    // this.flicker = this.flicker.bind(this);\n  } // static createBomb(grid, playerPosition, explosionSize) {\n  //     \n  //     Bomb.deploy(Grid.gridArray, position);\n  //     setTimeout(() => Bomb.explode(Grid.gridArray, position, explosionSize), 3000);\n  //     // setTimeout(this.flicker, 2000);\n  // }\n\n\n  explodeBothWays(position, upClear = true, downClear = true, leftClear = true, rightClear = true, obstacleClearUp = true, obstacleClearDown = true, obstacleClearLeft = true, obstacleClearRight = true) {\n    // let position = this.player.grid.canvasToArray([this.player.position.x, this.player.position.y]);\n    let row = position[0];\n    let col = position[1];\n    let gridArray = this.player.grid.gridArray;\n    let bombSize = this.player.bombSize; //4\n\n    for (let i = 1; bombSize > 0; i++) {\n      //UP---------\n      //not on border, not a Wall, not an Obstacle => change gridArray letter to E && decrement bombsize\n      if (row - i >= 1 && gridArray[row - i][col] != 'W' && gridArray[row - i][col] != 'O' && upClear && obstacleClearUp) {\n        bombSize -= 1;\n        gridArray[row - i][col] = 'E';\n        if (bombSize === 0) break; //if it is an obstacle OR we've already encountered an obstacle in the up direction\n      } else if (row - i >= 1 && gridArray[row - i][col] === 'O' || !obstacleClearUp) {\n        //if it's the first obstacle we've encoutered, destroy it and set boolean false but still decrement so explosion doesn't extend\n        if (obstacleClearUp) {\n          gridArray[row - i][col] = 'EO';\n          obstacleClearUp = false;\n        }\n\n        bombSize -= 1;\n        if (bombSize === 0) break; //it's a wall\n      } else {\n        upClear = false;\n      } //DOWN---------\n\n\n      if (row + i <= 15 && gridArray[row + i][col] != 'W' && downClear) {\n        // debugger \n        bombSize -= 1;\n        gridArray[row + i][col] = 'E';\n        if (bombSize === 0) break;\n      } else if (row + i <= 15 && gridArray[row + i][col] === 'O' || !obstacleClearDown) {\n        // debugger\n        //if it's the first obstacle we've encoutered, destroy it and set boolean false\n        if (obstacleClearDown) {\n          gridArray[row + i][col] = 'EO';\n          obstacleClearDown = false;\n        }\n\n        bombSize -= 1;\n        if (bombSize === 0) break;\n      } else {\n        downClear = false;\n      } //LEFT---------\n\n\n      if (col - i >= 1 && gridArray[row][col - i] != 'W' && leftClear) {\n        bombSize -= 1;\n        gridArray[row][col - i] = 'E';\n        if (bombSize === 0) break;\n      } else if (col - i >= 1 && gridArray[row][col - i] === 'O' || !obstacleClearLeft) {\n        //if it's the first obstacle we've encoutered, destroy it and set boolean false\n        if (obstacleClearLeft) {\n          gridArray[row][col - i] = 'EO';\n          obstacleClearLeft = false;\n        }\n\n        bombSize -= 1;\n      } else {\n        leftClear = false;\n      } //RIGHT---------\n\n\n      if (col + i <= 15 && gridArray[row][col + i] != 'W' && rightClear) {\n        bombSize -= 1;\n        gridArray[row][col + i] = 'E';\n        if (bombSize === 0) break;\n      } else if (col + i <= 15 && gridArray[row][col + i] === 'O' || !obstacleClearRight) {\n        //if it's the first obstacle we've encoutered, destroy it and set boolean false\n        if (obstacleClearRight) {\n          gridArray[row][col + i] = 'EO';\n          obstacleClearRight = false;\n        }\n\n        bombSize -= 1;\n        if (bombSize === 0) break;\n      } else {\n        rightClear = false;\n      }\n    }\n  }\n\n  clearExplosion() {\n    let gridArray = this.player.grid.gridArray;\n\n    for (let row = 0; row < gridArray.length; row++) {\n      for (let col = 0; col < gridArray.length; col++) {\n        if (gridArray[row][col] === 'E') gridArray[row][col] = 'X';\n        if (gridArray[row][col] === 'EO') gridArray[row][col] = 'I';\n      }\n    }\n  }\n\n  deploy() {\n    const position = this.player.grid.canvasToArray([this.player.position.x, this.player.position.y]);\n    this.player.grid.gridArray[position[0]][position[1]] = 'B';\n    let row = position[0];\n    let col = position[1];\n    let gridArray = this.player.grid.gridArray;\n    setTimeout(() => {\n      this.player.grid.gridArray[position[0]][position[1]] = 'E';\n      this.explodeBothWays(position);\n    }, 2000);\n    setTimeout(() => {\n      this.clearExplosion(); // this.player.grid.gridArray[position[0]][position[1]] = 'X';\n\n      this.player.bombs.pickUp(this);\n    }, 3000);\n  } // explode(gridArray, position, explosionSize) {\n  //     let row = position[0];\n  //     let col = position[1];\n  //     gridArray[row][col] = 'E';\n  // }\n  // flicker() {\n  //     this.flickerIntervalId = setInterval(() => { }, 100);\n  // }\n\n\n}","map":{"version":3,"sources":["/home/aseemar/Desktop/JS_Projects/MERN_stack_project/frontend/src/bummerman/bombs/bomb.js"],"names":["Bomb","renderBomb","ctx","position","fillStyle","fillRect","renderExplosion","constructor","player","deploy","bind","explodeBothWays","upClear","downClear","leftClear","rightClear","obstacleClearUp","obstacleClearDown","obstacleClearLeft","obstacleClearRight","row","col","gridArray","grid","bombSize","i","clearExplosion","length","canvasToArray","x","y","setTimeout","bombs","pickUp"],"mappings":"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","sourcesContent":["export default class Bomb {\n\n    static renderBomb(ctx, position){\n        ctx.fillStyle = \"#ff0000\";\n        ctx.fillRect(position[0], position[1], 48, 48);\n    }\n\n    static renderExplosion(ctx, position){\n        ctx.fillStyle = \"#ffff00\";\n        ctx.fillRect(position[0], position[1], 48, 48);\n    }\n\n    constructor(player) {\n        // this.img = '';\n        // this.flickerIntervalId = null;\n        // this.ctx = ctx;\n        // this.grid = grid;\n        this.player = player;\n        this.deploy = this.deploy.bind(this);\n\n        this.explodeBothWays = this.explodeBothWays.bind(this);\n        \n        // this.explode = this.explode.bind(this);\n        // this.flicker = this.flicker.bind(this);\n    }\n\n\n    // static createBomb(grid, playerPosition, explosionSize) {\n    //     \n\n        \n    //     Bomb.deploy(Grid.gridArray, position);\n    //     setTimeout(() => Bomb.explode(Grid.gridArray, position, explosionSize), 3000);\n\n    //     // setTimeout(this.flicker, 2000);\n    // }\n\n\n\n    explodeBothWays(\n        position, \n        upClear=true, \n        downClear=true, \n        leftClear=true, \n        rightClear=true, \n        obstacleClearUp = true,\n        obstacleClearDown = true,\n        obstacleClearLeft = true,\n        obstacleClearRight = true\n        ) {\n        // let position = this.player.grid.canvasToArray([this.player.position.x, this.player.position.y]);\n        let row = position[0];\n        let col = position[1];\n        let gridArray = this.player.grid.gridArray;\n        let bombSize = this.player.bombSize; //4\n    \n\n        for(let i = 1; bombSize >  0; i++){\n\n            //UP---------\n\n            //not on border, not a Wall, not an Obstacle => change gridArray letter to E && decrement bombsize\n            if (\n                row - i >= 1 \n                && gridArray[row - i][col] != 'W' \n                && gridArray[row - i][col] != 'O' \n                && upClear \n                && obstacleClearUp\n                ){\n                bombSize -= 1;\n                gridArray[row - i][col] = 'E';\n                if (bombSize === 0) break;\n            //if it is an obstacle OR we've already encountered an obstacle in the up direction\n            } else if ((row - i >= 1 && gridArray[row - i][col] === 'O') || !obstacleClearUp) {\n                //if it's the first obstacle we've encoutered, destroy it and set boolean false but still decrement so explosion doesn't extend\n                if (obstacleClearUp) {\n                    gridArray[row - i][col] = 'EO';\n                    obstacleClearUp = false;\n                }\n                bombSize -= 1;\n                if (bombSize === 0) break;\n            //it's a wall\n            } else {\n                upClear = false;\n            }\n\n            //DOWN---------\n\n            if (row + i <= 15 && gridArray[row + i][col] != 'W' && downClear){\n                // debugger \n                bombSize -= 1;\n                gridArray[row + i][col] = 'E';\n                if (bombSize === 0) break;\n            } else if ((row + i <= 15 && gridArray[row + i][col] === 'O') || !obstacleClearDown) {\n                // debugger\n                //if it's the first obstacle we've encoutered, destroy it and set boolean false\n                if (obstacleClearDown) {\n                    gridArray[row + i][col] = 'EO';\n                    obstacleClearDown = false;\n                }\n                bombSize -= 1;\n                if (bombSize === 0) break;\n            } else {\n                downClear = false;\n            }\n\n            //LEFT---------\n\n            if (col - i >= 1 && gridArray[row][col - i] != 'W' && leftClear){\n                bombSize -= 1;\n                gridArray[row][col - i] = 'E';\n                if (bombSize === 0) break;\n            } else if ((col - i >= 1 &&gridArray[row][col - i] === 'O') || !obstacleClearLeft) {\n                //if it's the first obstacle we've encoutered, destroy it and set boolean false\n                if (obstacleClearLeft) {\n                    gridArray[row][col - i] = 'EO';\n                    obstacleClearLeft = false;\n                }\n                bombSize -= 1;\n                \n            } else {\n                leftClear = false;\n            }\n\n            //RIGHT---------\n\n            if (col + i <= 15 && gridArray[row][col + i] != 'W' && rightClear){\n                bombSize -= 1;\n                gridArray[row][col + i] = 'E';\n                if (bombSize === 0) break;\n            } else if ((col + i <= 15 &&gridArray[row][col + i] === 'O') || !obstacleClearRight) {\n                //if it's the first obstacle we've encoutered, destroy it and set boolean false\n                if (obstacleClearRight) {\n                    gridArray[row][col + i] = 'EO';\n                    obstacleClearRight = false;\n                }\n                bombSize -= 1;\n                if (bombSize === 0) break;\n            } else {\n                rightClear = false;\n            }\n        }\n    }\n\n    clearExplosion(){\n        let gridArray = this.player.grid.gridArray;\n\n        for(let row = 0; row< gridArray.length; row++){\n            for(let col = 0; col < gridArray.length; col++){\n                if(gridArray[row][col] === 'E') gridArray[row][col] = 'X';\n                if(gridArray[row][col] === 'EO') gridArray[row][col] = 'I';\n            }\n        }\n    }\n    \n    deploy() {\n        const position = this.player.grid.canvasToArray([this.player.position.x, this.player.position.y]);\n        this.player.grid.gridArray[position[0]][position [1]] = 'B';\n        let row = position[0];\n        let col = position[1];\n        let gridArray = this.player.grid.gridArray;\n\n\n        \n        setTimeout(() => {\n\n            \n            this.player.grid.gridArray[position[0]][position[1]] = 'E';\n            this.explodeBothWays(position);\n\n            \n        }, 2000);\n        \n        setTimeout(() => {\n            this.clearExplosion();\n            // this.player.grid.gridArray[position[0]][position[1]] = 'X';\n            this.player.bombs.pickUp(this);\n            }, 3000);\n        \n    }\n\n    // explode(gridArray, position, explosionSize) {\n    //     let row = position[0];\n    //     let col = position[1];\n\n    //     gridArray[row][col] = 'E';\n\n    \n    // }\n    \n\n    // flicker() {\n    //     this.flickerIntervalId = setInterval(() => { }, 100);\n    // }\n\n}"]},"metadata":{},"sourceType":"module"}