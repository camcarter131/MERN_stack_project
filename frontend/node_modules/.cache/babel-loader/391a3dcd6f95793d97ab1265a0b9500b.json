{"ast":null,"code":"export default class Grid {\n  constructor(canvas, ctx) {\n    // this.ctx = canvas.getContext(\"2d\");\n    this.ctx = ctx;\n    this.height = canvas.height;\n    this.width = canvas.width;\n    this.gridArray = [...Array(15)].map(e => [\"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\"]);\n    console.log(this.canvasToArray([]));\n    this.createWalls();\n    this.renderGame(this.ctx);\n  } //populates gridarray with W's\n\n\n  createWalls() {\n    for (let i = 1; i < this.gridArray[0].length; i += 2) {\n      for (let j = 1; j < this.gridArray[0].length; j += 2) {\n        this.gridArray[i][j] = \"W\";\n      }\n    }\n  }\n\n  renderGame(ctx) {\n    this.gridArray.forEach((row, x) => {\n      row.forEach((el, y) => {\n        let canvasCoords = this.gridToCanvas([x, y]);\n\n        switch (el) {\n          case \"W\":\n            this.renderWall(ctx, canvasCoords);\n        }\n      });\n    });\n  }\n\n  renderWall(ctx, canvasCoords) {\n    ctx.fillStyle = \"#000000\";\n    ctx.fillRect(canvasCoords[0], canvasCoords[1], 48, 48);\n  } //hard code initial gridarray\n  //function to make that array reflect in canvas\n  //legend\n  //W = immovable wall\n  //O = perishable obstacle\n  //B = bomb\n  //F = bomb fire\n  //X = background image\n\n\n  arrayToCanvas(arrayCoordinates) {\n    return [48 * arrayCoordinates[1], 48 * arrayCoordinates[0]];\n  }\n\n  canvasToArray(canvasPosition) {\n    return [canvasPosition[1] / 48, canvasPosition[0] / 48];\n  }\n\n  drawGrid() {\n    for (let x = 0; x <= this.width; x += 48) {\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.height);\n    }\n\n    for (let y = 0; y <= this.height; y += 48) {\n      this.ctx.moveTo(0, y);\n      this.ctx.lineTo(this.width, y);\n    }\n\n    this.ctx.strokeStyle = \"black\";\n    this.ctx.stroke();\n  } // populateGrid() {\n  //     //COmment in if you want a bigass black border\n  //     // for (let x = 0; x < this.width; x += 48) {\n  //     //     this.ctx.fillStyle = \"#000000\";\n  //     //     this.ctx.fillRect(x, 0, 48, 48);\n  //     //     this.ctx.fillRect(x, this.height-48, 48, 48);\n  //     // }\n  //     // for (let y = 0; y < this.height; y += 48) {\n  //     //     this.ctx.fillStyle = \"#000000\";\n  //     //     this.ctx.fillRect(0, y, 48, 48);\n  //     //     this.ctx.fillRect(this.width-48, y, 48, 48);\n  //     // }\n  // }\n\n\n}","map":{"version":3,"sources":["/home/aseemar/Desktop/JS_Projects/MERN_stack_project/frontend/src/bummerman/grid.js"],"names":["Grid","constructor","canvas","ctx","height","width","gridArray","Array","map","e","console","log","canvasToArray","createWalls","renderGame","i","length","j","forEach","row","x","el","y","canvasCoords","gridToCanvas","renderWall","fillStyle","fillRect","arrayToCanvas","arrayCoordinates","canvasPosition","drawGrid","moveTo","lineTo","strokeStyle","stroke"],"mappings":"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","sourcesContent":["\nexport default class Grid {\n\n    constructor(canvas, ctx){\n        // this.ctx = canvas.getContext(\"2d\");\n        this.ctx = ctx;\n        this.height = canvas.height;\n        this.width = canvas.width;\n        this.gridArray = [...Array(15)].map(e => [\"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\"]);\n        console.log(this.canvasToArray([]))\n        this.createWalls();\n        this.renderGame(this.ctx);\n    }\n\n    //populates gridarray with W's\n    createWalls(){\n        for(let i=1; i<this.gridArray[0].length; i+=2){\n            for(let j = 1; j < this.gridArray[0].length; j += 2){\n                this.gridArray[i][j] = \"W\";\n            }\n        }\n    }\n\n    renderGame(ctx) {\n        this.gridArray.forEach((row, x) => {\n            row.forEach((el, y) => {\n                let canvasCoords = this.gridToCanvas([x, y]);\n                switch(el) {\n                    case \"W\":\n                        this.renderWall(ctx, canvasCoords);\n                }\n            })\n        })\n    }\n\n    renderWall(ctx, canvasCoords) {\n        ctx.fillStyle = \"#000000\";\n        ctx.fillRect(canvasCoords[0], canvasCoords[1], 48, 48);\n    }\n\n  \n\n\n\n\n\n\n\n    //hard code initial gridarray\n    //function to make that array reflect in canvas\n\n    //legend\n    //W = immovable wall\n    //O = perishable obstacle\n    //B = bomb\n    //F = bomb fire\n    //X = background image\n\n    arrayToCanvas(arrayCoordinates) {\n        return [48*arrayCoordinates[1], 48*arrayCoordinates[0]];\n    }\n\n    canvasToArray(canvasPosition) {\n        return [canvasPosition[1] / 48, canvasPosition[0] / 48];\n    }\n\n\n    drawGrid() {\n        for (let x = 0; x <= this.width; x += 48) {\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, this.height);\n        }\n\n        for (let y = 0; y <= this.height; y += 48) {\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(this.width, y);\n        }\n        this.ctx.strokeStyle = \"black\";\n        this.ctx.stroke();\n    }\n\n    // populateGrid() {\n    //     //COmment in if you want a bigass black border\n    //     // for (let x = 0; x < this.width; x += 48) {\n    //     //     this.ctx.fillStyle = \"#000000\";\n    //     //     this.ctx.fillRect(x, 0, 48, 48);\n    //     //     this.ctx.fillRect(x, this.height-48, 48, 48);\n    //     // }\n\n    //     // for (let y = 0; y < this.height; y += 48) {\n    //     //     this.ctx.fillStyle = \"#000000\";\n    //     //     this.ctx.fillRect(0, y, 48, 48);\n    //     //     this.ctx.fillRect(this.width-48, y, 48, 48);\n    //     // }\n\n    // }\n\n}\n\n"]},"metadata":{},"sourceType":"module"}