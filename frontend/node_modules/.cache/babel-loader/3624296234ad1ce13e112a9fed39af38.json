{"ast":null,"code":"const Wall = require('./wall');\n\nconst Object = require('./object');\n\nconst Bomb = require('./bombs/bomb');\n\nconst Item = require('./item');\n\nclass Grid {\n  constructor(canvas, ctx) {\n    this.ctx = ctx;\n    this.height = canvas.height;\n    this.width = canvas.width;\n    this.gridArray = [...Array(17)].map(e => [\"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\"]);\n    this.createWalls(); // this.createObjects();\n    // this.renderGame(this.ctx);\n  } //populates gridarray with W's\n\n\n  createWalls() {\n    let rowTop = 0;\n    let rowBottom = 16;\n\n    for (let col = 0; col < this.gridArray[0].length; col += 1) {\n      this.gridArray[rowTop][col] = \"W\";\n      this.gridArray[rowBottom][col] = \"W\";\n    }\n\n    let colLeft = 0;\n    let colRight = 16;\n\n    for (let row = 0; row < this.gridArray[0].length; row += 1) {\n      this.gridArray[row][colLeft] = \"W\";\n      this.gridArray[row][colRight] = \"W\";\n    }\n\n    for (let i = 2; i < this.gridArray[0].length - 1; i += 2) {\n      for (let j = 2; j < this.gridArray[0].length - 1; j += 2) {\n        this.gridArray[i][j] = \"W\";\n      }\n    }\n  }\n\n  createObjects() {\n    // let numObjects = 25;\n    for (let i = 1; i < this.gridArray[0].length - 1; i += 1) {\n      for (let j = 1; j < this.gridArray[0].length - 1; j += 1) {\n        // if (i === 15 && j === 15) break;\n        if (i === 1 && j === 15 || i === 1 && j === 1 || i === 15 && j === 1 || i === 15 && j === 15) continue;\n        if (this.gridArray[i][j] === \"W\") continue;\n\n        if (Math.random() < .25) {\n          this.gridArray[i][j] = \"O\"; // numObjects -= 1;\n        }\n      }\n    }\n  } // Goes through master array and renders element in legend\n  //legend\n  //W = immovable wall\n  //O = perishable obstacle\n  //B = bomb\n  //F = bomb fire\n  //X = background image\n  //I1 = item 1 etc.....\n\n\n  renderGame() {\n    this.gridArray.forEach((row, x) => {\n      row.forEach((el, y) => {\n        let canvasCoords = this.arrayToCanvas([x, y]);\n\n        switch (el) {\n          case \"W\":\n            let wall = new Wall(this.ctx, canvasCoords);\n            wall.render();\n            break;\n\n          case \"O\":\n            let object = new Object(this.ctx, canvasCoords);\n            object.render();\n            break;\n\n          case \"B\":\n            Bomb.renderBomb(this.ctx, canvasCoords);\n            break;\n\n          case \"E\":\n            Bomb.renderExplosion(this.ctx, canvasCoords);\n            break;\n\n          case \"EO\":\n            Bomb.renderExplosionObstacle(this.ctx, canvasCoords);\n            break;\n\n          case \"I1\":\n            Item.renderI1(this.ctx, canvasCoords);\n            break;\n\n          case \"I2\":\n            Item.renderI2(this.ctx, canvasCoords);\n            break;\n\n          default:\n            break;\n        }\n      });\n    });\n  }\n\n  arrayToCanvas(arrayCoordinates) {\n    return [48 * arrayCoordinates[1], 48 * arrayCoordinates[0]];\n  }\n\n  canvasToArray(canvasPosition) {\n    //where x is the row and y is the column in the nested array.\n    let x = Math.floor(canvasPosition[1] / 48) * 48;\n    let y = Math.floor(canvasPosition[0] / 48) * 48;\n    return [x / 48, y / 48];\n  }\n\n  drawGrid() {\n    for (let x = 0; x <= this.width; x += 48) {\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.height);\n    }\n\n    for (let y = 0; y <= this.height; y += 48) {\n      this.ctx.moveTo(0, y);\n      this.ctx.lineTo(this.width, y);\n    }\n\n    this.ctx.strokeStyle = \"black\";\n    this.ctx.stroke();\n  } // populateGrid() {\n  //     //COmment in if you want a bigass black border\n  //     // for (let x = 0; x < this.width; x += 48) {\n  //     //     this.ctx.fillStyle = \"#000000\";\n  //     //     this.ctx.fillRect(x, 0, 48, 48);\n  //     //     this.ctx.fillRect(x, this.height-48, 48, 48);\n  //     // }\n  //     // for (let y = 0; y < this.height; y += 48) {\n  //     //     this.ctx.fillStyle = \"#000000\";\n  //     //     this.ctx.fillRect(0, y, 48, 48);\n  //     //     this.ctx.fillRect(this.width-48, y, 48, 48);\n  //     // }\n  // }\n\n\n}\n\nmodule.exports = Grid;","map":{"version":3,"sources":["/Users/cameroncarter/Desktop/aA-flex/frontend/src/bummerman/grid.js"],"names":["Wall","require","Object","Bomb","Item","Grid","constructor","canvas","ctx","height","width","gridArray","Array","map","e","createWalls","rowTop","rowBottom","col","length","colLeft","colRight","row","i","j","createObjects","Math","random","renderGame","forEach","x","el","y","canvasCoords","arrayToCanvas","wall","render","object","renderBomb","renderExplosion","renderExplosionObstacle","renderI1","renderI2","arrayCoordinates","canvasToArray","canvasPosition","floor","drawGrid","moveTo","lineTo","strokeStyle","stroke","module","exports"],"mappings":"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","sourcesContent":["const Wall = require('./wall');\nconst Object = require('./object');\nconst Bomb = require('./bombs/bomb');\nconst Item = require('./item');\n\nclass Grid {\n\n    constructor(canvas, ctx){\n        this.ctx = ctx;\n        this.height = canvas.height;\n        this.width = canvas.width;\n        this.gridArray = [...Array(17)].map(e => [\"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\"]);\n        this.createWalls();\n        // this.createObjects();\n        // this.renderGame(this.ctx);\n    }\n\n    //populates gridarray with W's\n    createWalls(){\n        let rowTop = 0;\n        let rowBottom = 16;\n        for (let col = 0; col < this.gridArray[0].length; col+= 1) {\n            this.gridArray[rowTop][col] = \"W\";\n            this.gridArray[rowBottom][col] = \"W\";\n        }\n        let colLeft = 0;\n        let colRight = 16;\n        for (let row = 0; row < this.gridArray[0].length; row+= 1) {\n            this.gridArray[row][colLeft] = \"W\";\n            this.gridArray[row][colRight] = \"W\";\n        }\n        for(let i=2; i<this.gridArray[0].length-1; i+=2){\n            for(let j = 2; j < this.gridArray[0].length-1; j += 2){\n                this.gridArray[i][j] = \"W\";\n            }\n        }\n\n    }\n\n    createObjects(){\n        // let numObjects = 25;\n        for(let i=1; i<this.gridArray[0].length-1; i+=1){\n            for(let j = 1; j < this.gridArray[0].length-1; j += 1){\n                // if (i === 15 && j === 15) break;\n                if ((i === 1 && j === 15) || (i === 1 && j === 1) || (i === 15 && j === 1) || (i === 15 && j === 15)) continue;\n                if (this.gridArray[i][j] === \"W\") continue;\n                if (Math.random() < .25) {\n                    this.gridArray[i][j] = \"O\";\n                    // numObjects -= 1;\n                }\n            }\n        }\n    }\n\n    // Goes through master array and renders element in legend\n\n     //legend\n    //W = immovable wall\n    //O = perishable obstacle\n    //B = bomb\n    //F = bomb fire\n    //X = background image\n    //I1 = item 1 etc.....\n\n    renderGame() {\n        this.gridArray.forEach((row, x) => {\n            row.forEach((el, y) => {\n                let canvasCoords = this.arrayToCanvas([x, y]);\n                switch(el) {\n                    case \"W\":\n                        let wall = new Wall(this.ctx, canvasCoords)\n                        wall.render();\n                        break;\n                    case \"O\":\n                        let object = new Object(this.ctx, canvasCoords)\n                        object.render();\n                        break;\n                    case \"B\":\n                        Bomb.renderBomb(this.ctx, canvasCoords);\n                        break;\n                    case \"E\":\n                        Bomb.renderExplosion(this.ctx, canvasCoords);\n                        break;\n                    case \"EO\":\n                        Bomb.renderExplosionObstacle(this.ctx, canvasCoords);\n                        break;\n                    case \"I1\":\n                        Item.renderI1(this.ctx, canvasCoords);\n                        break;\n                    case \"I2\":\n                        Item.renderI2(this.ctx, canvasCoords);\n                        break;\n                    default:\n                        break;\n                }\n            });\n        });\n    }\n\n\n   \n\n    arrayToCanvas(arrayCoordinates) {\n        return [48*arrayCoordinates[1], 48*arrayCoordinates[0]];\n    }\n\n\n    canvasToArray(canvasPosition) {\n        //where x is the row and y is the column in the nested array.\n        let x = Math.floor(canvasPosition[1]/48) * 48;\n        let y = Math.floor(canvasPosition[0]/48) * 48;\n        return [x / 48, y / 48];\n    }\n\n\n    drawGrid() {\n        for (let x = 0; x <= this.width; x += 48) {\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, this.height);\n        }\n\n        for (let y = 0; y <= this.height; y += 48) {\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(this.width, y);\n        }\n        this.ctx.strokeStyle = \"black\";\n        this.ctx.stroke();\n    }\n\n    // populateGrid() {\n    //     //COmment in if you want a bigass black border\n    //     // for (let x = 0; x < this.width; x += 48) {\n    //     //     this.ctx.fillStyle = \"#000000\";\n    //     //     this.ctx.fillRect(x, 0, 48, 48);\n    //     //     this.ctx.fillRect(x, this.height-48, 48, 48);\n    //     // }\n\n    //     // for (let y = 0; y < this.height; y += 48) {\n    //     //     this.ctx.fillStyle = \"#000000\";\n    //     //     this.ctx.fillRect(0, y, 48, 48);\n    //     //     this.ctx.fillRect(this.width-48, y, 48, 48);\n    //     // }\n\n    // }\n\n}\n\nmodule.exports = Grid;"]},"metadata":{},"sourceType":"module"}